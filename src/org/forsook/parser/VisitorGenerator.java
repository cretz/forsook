package org.forsook.parser;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class VisitorGenerator {
    
    private String indent = "    ";
    private String className = "Visitor";
    private String newline = "\n";
    
    public String getIndent() {
        return indent;
    }
    
    public void setIndent(String indent) {
        this.indent = indent;
    }
    
    public String getClassName() {
        return className;
    }
    
    public void setClassName(String className) {
        this.className = className;
    }
    
    public String getNewline() {
        return newline;
    }
    
    public void setNewline(String newline) {
        this.newline = newline;
    }
    
    public StringBuilder generate(Set<Class<?>> classes) {
        //load all classes and children into map
        Comparator<Class<?>> classComparator = new Comparator<Class<?>>() {
            @Override
            public int compare(Class<?> one, Class<?> two) {
                return one.getSimpleName().compareTo(two.getSimpleName());
            }
        };
        Map<Class<?>, ClassInfo> classInfos = new TreeMap<Class<?>, ClassInfo>(classComparator);
        for (Class<?> clas : classes) {
            //no package info...
            if (!clas.getName().endsWith(".package-info")) {
                addClassInfo(clas, classInfos);
            }
        }
        //imports
        Set<String> imports = new TreeSet<String>();
        imports.add("java.util.List");
        //now start creating the methods
        StringBuilder ret = new StringBuilder(newline).append("@SuppressWarnings(\"all\")").
                append(newline).
                append("public class ").append(className).append(" {").append(newline).
                append(indent).
                append("//generated by VisitorGenerator").append(newline);
        for (ClassInfo info : classInfos.values()) {
            ret.append(buildMethod(info, imports));
        }
        ret.append('}').append(newline);
        //make imports
        StringBuilder importStr = new StringBuilder();
        for (String mport : imports) {
            if (!mport.startsWith("java.lang")) {
                importStr.append("import ").append(mport).append(';').append(newline);
            }
        }
        return importStr.append(ret);
    }
    
    private Class<?> getListClass(Method method) {
        try {
            Type type = ((ParameterizedType) method.
                    getGenericReturnType()).getActualTypeArguments()[0];
            if (type instanceof Class<?>) {
                return (Class<?>) type;
            } else {
                return (Class<?>) ((ParameterizedType) type).getRawType();
            }
        } catch (Exception e) {
            throw new RuntimeException("Error parsing return type for " +
                    method, e);
        }
    }
    
    private void addClassInfo(Class<?> clas, Map<Class<?>, ClassInfo> classes) {
        if (clas.getName().startsWith("java.lang")) {
            return;
        }
        ClassInfo info = classes.get(clas);
        if (info == null) {
            info = new ClassInfo(clas);
            classes.put(clas, info);
        }
        //parent classes
        Class<?> parent = clas.getSuperclass();
        while (parent != null) {
            ClassInfo parentInfo = classes.get(parent);
            if (parentInfo == null) {
                parentInfo = new ClassInfo(parent);
                classes.put(parent, parentInfo);
            }
            parentInfo.childClasses.add(clas);
            parent = parent.getSuperclass();
        }
        //interfaces
        for (Class<?> iface : clas.getInterfaces()) {
                ClassInfo parentInfo = classes.get(iface);
            if (parentInfo == null) {
                parentInfo = new ClassInfo(iface);
                classes.put(iface, parentInfo);
            }
            parentInfo.childClasses.add(clas);
        }
        //check all getters for possibly unforeseen classes
        for (Method method : info.className.getMethods()) {
            if ((method.getName().startsWith("is") || 
                    method.getName().startsWith("get")) &&
                    method.getParameterTypes().length == 0 &&
                    !"getClass".equals(method.getName())) {
                if (!method.getReturnType().isPrimitive() &&
                        !"java.lang.String".equals(method.getReturnType().getName())) {
                    Class<?> resultClass = method.getReturnType();
                    if (resultClass == List.class) {
                        resultClass = getListClass(method);
                    }
                    if (!classes.containsKey(resultClass)) {
                        addClassInfo(resultClass, classes);
                    }
                }
            }
        }
    }
    
    private StringBuilder buildMethod(ClassInfo info, Set<String> imports) {
        StringBuilder ret = new StringBuilder();
        imports.add(info.className.getName().replace('$', '.'));
        ret.append(newline).append(indent).append("public void visit(").
            append(info.className.getSimpleName()).
            append(" a) {").append(newline);
        if (info.className.isEnum()) {
            ret.append(indent).append(indent).append("//do nothing with enum").
                append(newline).append(indent).append('}').append(newline);
            return ret;
        }
        boolean concrete = !info.className.isInterface() && 
                !Modifier.isAbstract(info.className.getModifiers());
        //interfaces and abstract classes are just instanceof lists
        ret.append(indent).append(indent).append("if (a == null) {").
            append(newline).append(indent).append(indent).append(indent).append("return;").
            append(newline).append(indent).append(indent).append('}');
        if (!info.childClasses.isEmpty()) {
            for (Class<?> child : info.childClasses) {
                imports.add(child.getName().replace('$', '.'));
                ret.append(" else if (a instanceof ").append(child.getSimpleName()).
                    append(") {").append(newline).append(indent).append(indent).append(indent).
                    append("visit((").append(child.getSimpleName()).
                    append(") a);").append(newline).append(indent).append(indent).append('}');
            }
            if (!concrete) {
                ret.append(" else {").append(newline).append(indent).append(indent).
                append(indent).append("throw new RuntimeException(").
                    append("\"Unknown type: \" + a.getClass());").append(newline).
                    append(indent).append(indent).append('}').append(newline);
            } else {
                ret.append(newline);
            }
        } else {
            ret.append(newline);
        }
        //concrete
        if (concrete) {
            //we have to go through every single property...
            ret.append(indent).append(indent).
                append("Object o = null;").append(newline);
            for (Method method : info.className.getMethods()) {
                if ((method.getName().startsWith("is") || 
                        method.getName().startsWith("get")) &&
                        method.getParameterTypes().length == 0 &&
                        !"getClass".equals(method.getName())) {
                    //no primitives here
                    if (method.getReturnType().isPrimitive() ||
                            "java.lang.String".equals(method.getReturnType().getName())) {
                        continue;
                    }
                    ret.append(indent).append(indent).append("o = a.").append(method.getName()).
                        append("();").append(newline).append(indent).append(indent).
                        append("if (o != null) {").append(newline).append(indent).
                        append(indent).append(indent);
                    //return type list?
                    if (method.getReturnType() == List.class) {
                        Class<?> listClass = getListClass(method);
                        imports.add("java.util.List");
                        imports.add(listClass.getName().replace('$', '.'));
                        ret.append("for (").append(listClass.getSimpleName()).
                            append(" l : (List<").append(listClass.getSimpleName()).
                            append(">) o) {").append(newline).append(indent).
                            append(indent).append(indent).append(indent).
                            append("visit((").append(listClass.getSimpleName()).
                            append(") l);").append(newline).append(indent).append(indent).
                            append(indent).append('}').append(newline).append(indent).
                            append(indent).append('}').append(newline);
                    } else {
                        imports.add(method.getReturnType().getName().replace('$', '.'));
                        //not primitive or string means an object to visit
                        ret.append("visit((").append(method.getReturnType().getSimpleName()).
                            append(") o);").append(newline).append(indent).append(indent).
                            append('}').append(newline);
                    }
                }
            }
        }
        return ret.append(indent).append('}').append(newline);
    }
    
    private static class ClassInfo {
        private Class<?> className;
        private final Set<Class<?>> childClasses = new HashSet<Class<?>>();
        
        private ClassInfo(Class<?> className) {
            this.className = className;
        }
    }
}
